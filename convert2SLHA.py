#!/usr/bin/env python3

# Extracts information from MadGraph output to create a SLHA file with cross-section blocks
# 1) Run getSLHA to extract the information of the MadGraph output
# and generate a SLHA file containing the cross-sections

import sys,os
import logging
from collections import OrderedDict
import gzip
logger = logging.getLogger()



def getSLHAFile(inputLHE,outputSLHA=None,pidList=[-5000002,5000002]):
    """
    Uses the LHE file generated by MadGraph
    to generate an SLHA file which includes the XSECTION blocks.
    
    :param parser: ConfigParser object with all the parameters needed
    :param inputLHE: Path to the MadGraph LHE file.  
    :param outputSLHA: Name for the SLHA output. If not given, will use inputLHE+.slha.  
    :param pidList: List of final states PIDs for the process (assumes a single process),
                 used for defining the xsection block. If not given, will try to read it from
                 the process card.
                 
    
    :return: Path to the slha file
    """
    

    if outputSLHA is None:
        outputSLHA = inputLHE[:inputLHE.rfind('.lhe')]+'.slha'
    
    #Use MadGraph banner reader:
    madgraphPath = os.path.abspath('./MG5')
    sys.path.append(madgraphPath)
    from madgraph.various.banner import Banner
        
    #Create output dirs, if do not exist:
    try:
        os.makedirs(os.path.dirname(outputSLHA))
    except:
        pass    
    
    slhaFile = outputSLHA
    logger.debug('Creating SLHA file %s' %slhaFile)
    
    
    lheFile = inputLHE   
    if not os.path.isfile(lheFile):
        logger.error("File %s not found" %lheFile)
        return False
    
    if lheFile[-3:] == '.gz':
        f = gzip.open(lheFile, 'rt')
    else: 
        f = open(lheFile,'r')
    banner = Banner()
    banner.read_banner(f)
    f.close()
    #Check if input file is MG5 banner or SLHA file

    if not 'init' in banner or not 'slha' in banner:
        logger.error("Input file %s does not contain required data " %lheFile)
        return False
       
    # Collect necessary info:
    slhaData = banner['slha'] 

    if pidList is None or not pidList:
        # Use QNUMBERS blocks to get particle label -> PDG dict:
        slhaLines = slhaData.split('\n')  
        qnumbers = [l for l in slhaLines if 'block qnumbers' in l.lower()]
        particleLabels = {x.split('#')[1].strip() : eval(x.split('#')[0].split()[-1]) for x in qnumbers}
        # Try to guess anti-particle labels:
        for label,pdg in list(particleLabels.items()):
            if -pdg in particleLabels.values():
                continue
            else:
                particleLabels[label+'~'] = -pdg    

        #Get generated processes:
        finalStatesDict = {}
        iproc = 0
        for l in banner['mg5proccard'].split('\n'):
            if not l or l[0] == '#':
                continue
            l = l.strip()
            if l[:8] == 'generate':
                l = l[l.find('generate')+8:]
            elif l[:11] == 'add process':
                l = l[l.find('add process')+11:]
            else:
                continue

            l = l[:l.find('[')]
            l = l.strip()        
            #Get final states and process ID
            finalStates = l.split('>')[1]
            finalStates = finalStates.split(',')[0]
            finalStates = finalStates.strip().split()
            finalStates = [particleLabels[f] if f in particleLabels else f
                            for f in finalStates[:]]

            #Store the process ID with its final states:
            if not iproc in finalStatesDict:        
                finalStatesDict[iproc] = finalStates
            else:
                logger.error("Error reading processes. Process ID %i appears more than once." %iproc)
                return False
            iproc += 1
    else:
        finalStatesDict = {1 : sorted(pidList)}

    #Get total cross-section,number of events
    xsecTotal = banner.get_cross()
    if xsecTotal <= 0.:
        logger.error("Total cross-section is zero?")
        return False
    
    #Get sqrts and cross-section for each process:
    info = banner['init'].split('\n')[0].split()
    sqrts = eval(info[2]) + eval(info[3])
    pdgInitial = list(banner.get_pdg_beam())
    processXsecs = {}
    for l in banner['init'].split('\n')[1:]:
        if not l.strip() or l.strip()[0] == '<':
            continue
        vals = [eval(x) for x in l.split()]
        xsec,xsecErr,_,procID = vals
        if not procID in finalStatesDict:
            logger.error("Process ID %i not found in LHE file" %procID)
            return False
        if not procID in processXsecs:
            processXsecs[procID] = {'xsec (pb)' : xsec, 'xsecErr (pb)' : xsecErr}
        else:
            logger.error("Error reading subprocess cross-sections. The process ID = %i appears multiple times" %procID)
            return False


    #Check:
    if abs(xsecTotal - sum([x['xsec (pb)'] for x in processXsecs.values()]))/xsecTotal > 0.001:
        logger.error("Total cross-section does not agree with sum of subprocesses")
        return False 
    
    #Write SLHA file:
    slhaF = open(slhaFile,'w')
    slhaF.write(slhaData)
    slhaF.write('\n\n')
    processXsecs = OrderedDict(sorted(processXsecs.items(), 
                                      key=lambda proc: proc[1]['xsec (pb)'],reverse=True))
    for procID in processXsecs:
        finalStates = finalStatesDict[procID]
        xsec = processXsecs[procID]['xsec (pb)']
        xsecErr = processXsecs[procID]['xsecErr (pb)']
        comment = "# xsec unit: pb xsec error: %1.3e" %(xsecErr)
        xsecLine = "\nXSECTION %1.3e " %(sqrts)
        xsecLine += " ".join([str(pdg) for pdg in pdgInitial])
        xsecLine += " %i " %len(finalStates)
        xsecLine += " ".join([str(pdg) for pdg in finalStates])
        slhaF.write(xsecLine+' '+comment+' \n')        
        slhaF.write("  0  0  0  0  0  0  %1.4e ufo2slha 1.0\n" %xsec)    
    slhaF.close()
    
    logger.info("Finished SLHA creation")
    
    return slhaFile




if __name__ == "__main__":
    
    import argparse    
    ap = argparse.ArgumentParser( description=
            "Read a LHE event file generate by MG5 and convert it to a SLHA file with cross-section blocks." )
    ap.add_argument('-f', '--input',
            help='path to the LHE input file.')
    ap.add_argument('-o', '--output',
            help='name of output (SLHA) file. If not given the input file name will be used.',default=None)
    ap.add_argument('-pids', '--pids',
            help='list of final state PIDs (e.g. -1000011 1000011). If not given, will try to guess from process card.',
            default=[-5000002,5000002],nargs='+')
    
    args = ap.parse_args()
    output = getSLHAFile(args.input,args.output,args.pids)
            
    print("\n%s created.\n" %output)
